classdef Robot < handle

    properties
        % Save vector of tubes and size of vector
        tubes = []
        num_tubes = 0

        % Save link lengths, phi values, and kappa values vectors (1 x num
        % links)
        lls = []
        phi = []
        kappa = []
    end

    methods
        % Constructor. This creates an instance of the robot class 
        % Must pass in a vector of tubes
        function self = Robot(tubes)
            self.tubes = tubes;
            self.num_tubes = size(tubes, 2);
        end

        % Here we calculate the kinematics of a full CTR
        % Pass in the raw joint variables
        % Return transformation matrix that goes from home frame to end
        % effector frame
        % See functions below for each step
        function T = fkin(self, q_var)  
            % First we get the rho and theta avlues from q_var
            rho = get_rho_values(self, q_var); 
            theta = get_theta(self, q_var);

            % Next, we use rho to get the link lengths
            self.lls = get_links(self, rho);

            % Now we calculate the phi and kappa values
            [self.phi,self.kappa] = calculate_phi_and_kappa(self, theta, rho);

            % Finally we calculate the base to end effector transform
            T = calculate_transform(self, self.lls, self.phi, self.kappa);
        end

        % Get rho values from joint positions
        % Return rho (1 x i vector, i is num tubes)
        function rho = get_rho_values(self, q_var)
            % Here we extract rho values from the q_var vector

            % Initialize a vector to hold the result
            rho = zeros([1 self.num_tubes]);

            for i=2:self.num_tubes
                rho(i) = (q_var(i) - q_var(1)) * 10^-3;
            end

        end

        % Function to find the link lengths, in order
        % Returns link lengths (1 x j vector, where j is num links)
        function s = get_links(self, rho)
            % ********************************************************
            %                          TODO
            % ********************************************************
            d = [self.tubes.d];
            [transition_zones, ~] = sort([rho, d+rho]);
            transition_zones = unique(transition_zones, 'stable');
            s = diff(transition_zones);
            s = s(s ~= 0);
           
        end

        % Function to get theta values
        % Returns theta (1 x j vector where j is num links)
        function theta = get_theta(self, q_var)
            % Here we extract theta values from the q_var vector

            % Initialize a vector to hold the result
            theta = zeros([1 self.num_tubes]);

            for i=1:self.num_tubes
                theta(i) = deg2rad(q_var(i+self.num_tubes));
            end
        end

        function [chi,gamma] = linkcurvature(self, E, OD, ID, k, theta)
            % *YOUR CODE HERE*
            I = pi * (OD.^4 - ID.^4) / 64;
            chi = sum(E.*I.*k.*cos(theta)) / sum(E.*I);
            gamma = sum(E.*I.*k.*sin(theta)) / sum(E.*I);
        end


        % Function to calcualte phi values for two or three tube
        % configurations
        % Should return phi (1 x j vector, where j is num links)
        % and K (1 x j vector)
        function [phi,K] = calculate_phi_and_kappa(self, theta, rho)
            % ********************************************************
            %                          TODO
            % ********************************************************
            ll = self.lls;
            n_links = size(ll, 2);

            K   = zeros(1,n_links); % Link Curvatures [m^-1]
            phi = zeros(1,n_links); % Link Rotations [rad]

            d = [self.tubes.d];
            E = [self.tubes.E];
            OD = [self.tubes.od];
            ID = [self.tubes.id];
            k = [self.tubes.k];

            % sorted tube properties 
            total_tube_length = d+rho;
            length_list = [0, cumsum(ll)];

            for i = 1:n_links
                present_tubes = total_tube_length > length_list(i); % present tubes
                tube_idx = find(present_tubes == 1);
                straight_tubes = rho(tube_idx) > length_list(i); % check if the tube is straight 
                curved_tubes =  ~straight_tubes & present_tubes(tube_idx); % check if curved if not straight 
                k_tran = curved_tubes .* k(tube_idx); % only include present tubes
                
                    
                [chi,gamma] = self.linkcurvature(E(tube_idx), OD(tube_idx), ID(tube_idx), k_tran, theta(tube_idx));
                K(i) = sqrt(chi^2 + gamma^2);
                if i == 1
                    phi(i) = atan2(gamma, chi); % delta phi 
                else
                    phi(i) = atan2(gamma, chi) - phi(i-1); % delta phi 
                end 
                
            end 

        end

        function T = arckinematics(self, k, phi, l)
        %% YOUR CODE HERE
            if k > 0
                R = [cos(phi)*cos(k*l), -sin(phi), cos(phi)*sin(k*l);
                    sin(phi)*cos(k*l), cos(phi), sin(phi)*sin(k*l);
                    -sin(k*l), 0, cos(k*l)];
                
                p = [(cos(phi) * (1-cos(k*l))) / k;
                            (sin(phi) * (1-cos(k*l))) / k;
                            sin(k*l) / k];
            else 
                R = [cos(phi), -sin(phi), 0;
                    sin(phi), cos(phi), 0;
                    0 0 1];
                p = [0; 0; l;];
                
            end 
            T = [R p;
                0 0 0 1];

        end

        % Take in all robot dependent parameters (lls, phi, kappa) and
        % compelte the robot independent constant curvature kinamtatics
        % Returns a 4x4 transformation matrix from base frame to end
        % effector
        function T = calculate_transform(self, s, phi, K)
            % ********************************************************
            %                          TODO
            % ********************************************************
            T = eye(4);
            for ii = 1 : size(self.lls, 2)
                Tii = self.arckinematics(K(ii), phi(ii), s(ii));
                T = T * Tii;
            end

        end
    end
end

